#!/usr/bin/env bash
# commit-msg hook: Conventional Commits + newline hygiene
# - Reject literal "\n" sequences in the commit message
# - Enforce CC subject line format via regex
# - Optional cocogitto verification

MSG_FILE="$1"

# 1) Reject literal \n sequences
if grep -q '\\n' "$MSG_FILE"; then
  echo "[commit-msg] Found literal '\\n' in commit message. Use real newlines or multiple -m flags."
  exit 1
fi

# 2) Extract subject and validate Conventional Commits format
subject=$(sed -n '1{s/[ \t]*$//;p}' "$MSG_FILE")
if [ -z "$subject" ]; then
  echo "[commit-msg] Empty commit subject."
  exit 1
fi

cc_regex='^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-z0-9._-]+\))?!?: .+'
if ! printf '%s' "$subject" | grep -Eq "$cc_regex"; then
  echo "[commit-msg] Subject does not follow Conventional Commits:" >&2
  echo "  Got: $subject" >&2
  echo "  Expected: type(scope)?: subject" >&2
  echo "  Types: feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert" >&2
  exit 1
fi

# 3) Optional subject length check
if [ ${#subject} -gt 100 ]; then
  echo "[commit-msg] Subject exceeds 100 characters (limit: 100)." >&2
  exit 1
fi

# 4) Best-effort cocogitto verification
if command -v cog >/dev/null 2>&1; then
  # Always verify the current commit message file
  cog verify --file "$MSG_FILE" >/dev/null 2>&1 || {
    echo "[commit-msg] cocogitto verify failed on the commit message file." >&2
    exit 1
  }
  if [ "${COG_STRICT:-0}" = "1" ]; then
    echo "[commit-msg] Running cocogitto check (strict) on recent history..."
    # Prefer checking from latest tag; fallback to whole history
    cog check --from-latest-tag || cog check || {
      echo "[commit-msg] cocogitto check failed (strict mode)." >&2
      exit 1
    }
  fi
fi

exit 0
